<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>AEM Tutorial - AEM Architecture Stack</title>
        <link rel="stylesheet" href="css/styles.css">
    </head>
    <body>
        <nav class="sidebar" id="sidebar">
            <div class="logo">
                <h2>AEM Tutorial</h2>
            </div>
            <ul class="nav-list">
                <li><a href="index.html" class="nav-link">Introduction to AEM</a></li>
                <li><a href="aem-architecture-stack.html" class="nav-link active">AEM Architecture Stack</a></li>
                <li><a href="setting-up-aem.html" class="nav-link">Setting Up AEM</a></li>
                <li><a href="project-creation-and-deployment.html" class="nav-link">Project Creation & Deployment</a></li>
                <li><a href="sites-pages.html" class="nav-link">Sites & Pages</a></li>
                <li><a href="templates.html" class="nav-link">Templates</a></li>
                <li><a href="components.html" class="nav-link">Components</a></li>
            </ul>
        </nav>
        <div class="hamburger" id="hamburger" onclick="toggleMenu()">
            &#9776;
        </div>
        <main class="content">
            <h1>AEM Architecture Stack</h1>
            <div class="card">
                <p>The architecture stack of Adobe Experience Manager (AEM) is based on several key open-source technologies. Three of the most important components are <code>Apache Felix</code>, <code>Apache Jackrabbit</code>, and <code>Apache Sling</code>. These technologies work together to provide the foundational framework for AEM.</p>
                <img src="images/architecture-stack.png" alt="AEM Architecture Stack">
            </div>
            <div class="card">
                <h2>Apache Felix (OSGi Framework)</h2>
                <h3>Overview:</h3>
                <ul>
                    <li>Apache Felix is an open-source implementation of the OSGi (Open Services Gateway initiative) specification. OSGi is a dynamic module system for Java that allows developers to build modular applications where components (bundles) can be installed, updated, or removed without stopping the system.</li>
                    <li>AEM uses Apache Felix as the core service management layer. It handles the lifecycle of bundles, services, and configurations, providing a modular and dynamic environment.</li>
                    <li>The author instance communicates with the JCR (Java Content Repository) to store and manage content.</li>
                    <li>Bundle life cycle states are: <em>Installed, Resolved, Starting, Active, Stopping, Uninstalled.</em></li>
                </ul>
                <h3>Role in AEM:</h3>
                <ul>
                    <li><strong>Modularization: </strong>AEM uses Felix to break down its core functionality into modular bundles. This allows AEM to be extensible and configurable, where bundles can be added or removed depending on the requirements.</li>
                    <li><strong>Service Management: </strong>Felix manages the lifecycle of services that AEM uses, including content management, user management, and workflow services.</li>
                    <li><strong>Dynamic Updates: </strong>OSGi allows AEM to dynamically load and update bundles without restarting the system, providing better flexibility and scalability.</li>
                </ul>
                <h3>Key Benefits:</h3>
                <ul>
                    <li><strong>Flexibility: </strong>Easily add or remove functionalities through OSGi bundles.</li>
                    <li><strong>Scalability: </strong>OSGi helps scale the application by allowing different services to run independently in different bundles.</li>
                    <li><strong>Decoupling: </strong>Helps keep services and components decoupled, leading to cleaner code and easier maintenance.</li>
                </ul>
            </div>
            <div class="card">
                <h2>Apache Jackrabbit (JCR Implementation)</h2>
                <h3>Overview:</h3>
                <ul>
                    <li>Apache Jackrabbit is an open-source implementation of the Java Content Repository (JCR) specification. It provides a standard API for storing and managing content in a hierarchical repository, which is the core data store for AEM.</li>
                    <li>Jackrabbit allows the storage of structured and unstructured content and provides features like versioning, access control, and content queries.</li>
                </ul>
                <h3>Role in AEM:</h3>
                <ul>
                    <li><strong>Content Storage: </strong>Apache Jackrabbit is responsible for storing all the content in AEM, whether it’s structured data (e.g., page content) or unstructured data (e.g., images, videos).</li>
                    <li><strong>JCR API: </strong>AEM interacts with Jackrabbit using the JCR API, which allows developers to interact with content in a standardized way. This API includes functionality for CRUD operations, versioning, and querying content.</li>
                    <li><strong>Versioning and Locking: </strong>Jackrabbit provides version control for content, meaning AEM can keep track of content changes over time and roll back to previous versions if necessary. It also allows locking of content nodes to prevent concurrent updates from conflicting.</li>
                    <li><strong>Querying: </strong>Jackrabbit supports querying content using JCR-SQL2 or XPath query languages, which allows developers to search and retrieve content stored in the repository efficiently.</li>
                </ul>
                <h3>Key Benefits:</h3>
                <ul>
                    <li><strong>Hierarchical Content Storage: </strong>Jackrabbit stores content in a tree structure, making it easy to organize and manage.</li>
                    <li><strong>Content Versioning: </strong>Provides built-in version control, enabling content rollback and auditability.</li>
                    <li><strong>Standardized API: </strong>The JCR API provides a uniform way to interact with content, which can be used across different implementations of JCR.</li>
                    <li><strong>Content Querying: </strong>Jackrabbit’s powerful querying features allow for efficient search and retrieval of content.</li>
                </ul>
            </div>
            <div class="card">
                <h2>Apache Sling (Web Framework)</h2>
                <h3>Overview:</h3>
                <ul>
                    <li>Apache Sling is a web framework for Java that facilitates the development of content-driven applications. It is the web framework used by AEM to handle HTTP requests, map them to resources in the JCR (Java Content Repository), and render the requested content dynamically.</li>
                    <li>Sling uses the concept of Resource and URL Mapping, where each resource corresponds to a node in the content repository, and the URL is mapped to that resource.</li>
                    <li>It Provides <a href="#rest">RESTful</a> Web API to JCR based applications</li>
                </ul>
                <h3>Role in AEM:</h3>
                <ul>
                    <li><strong>Request Handling: </strong>Sling is responsible for routing incoming HTTP requests to the correct resources. It maps URLs to JCR nodes and uses servlets or other components to render content dynamically.</li>
                    <li><strong>Rendering Content: </strong>Sling handles the rendering of content using JSP, HTL (HTML Template Language), or other templating mechanisms. It allows developers to build content-driven applications where the content and structure are decoupled.</li>
                    <li><strong>URL Resolution: </strong>Sling uses the path of the URL to find a corresponding resource in the JCR repository. It supports flexible URL resolution and provides content dynamically based on the request.</li>
                </ul>
                <h3>Key Benefits:</h3>
                <ul>
                    <li><strong>Dynamic Content Resolution: </strong>Allows content to be served dynamically by resolving URLs to JCR nodes.</li>
                    <li><strong>Separation of Content and Presentation: </strong>Sling enables a clear separation between content (stored in JCR) and its presentation (rendered via HTL/JSP).</li>
                    <li><strong>Extensibility: </strong>Developers can extend Sling by writing custom Sling servlets, filters, and Sling models for handling specific content processing logic.</li>
                </ul>
            </div>
            <div class="card" id="rest">
                <h2>REST in Apache Sling (Web Framework)</h2>
                <p>REST (Representational State Transfer) is an architectural style that is commonly used in modern web applications. It defines a set of constraints that, when applied to web services, result in a lightweight, scalable, and easy-to-use service. Apache Sling, which powers AEM, is designed around the principles of REST to enable seamless interaction with resources stored in the Java Content Repository (JCR).</p>
                <p>The REST architectural style is based on six key constraints that shape the interaction between clients and servers:</p>
                <ul>
                    <li><strong>Uniform Interface - </strong>Resources are uniquely identified by URLs, and the representation of these resources (such as XML, JSON, or HTML) is separate from the actual resource (like a database entry). Clients interact with resources through these representations, provided they have the necessary permissions. Every message exchanged between the client and server is self-explanatory, containing all the information needed for processing. Hyperlinks and hypertext serve as the mechanism for transferring the state between the client and server.</li>
                    <li><strong>Stateless Interactions - </strong>Each client request is independent, meaning that the server does not retain any information about previous interactions. All necessary information to process a request must be included in the request itself, either through the URL, query parameters, headers, or body content.</li>
                    <li><strong>Cacheable - </strong>Responses sent by the server can be cached by the client to reduce unnecessary communication. The server must specify whether a response is cacheable or not to prevent outdated or inappropriate data from being used in subsequent requests.</li>
                    <li><strong>Client-Server - </strong>The client and server operate independently from one another. The client is responsible for the user interface and user interaction, while the server handles data storage and management. This separation improves the client’s portability since it is not dependent on the server's internal data structures, and it simplifies the server, allowing for easier scalability.</li>
                    <li><strong>Layered System - </strong>The architecture allows intermediates such as proxies, gateways, and load balancers between the client and the server. Clients cannot discern whether they are communicating with the end server or an intermediary. These intermediates can enhance system security and scalability by implementing policies like security and load-balancing without the client’s awareness.</li>
                    <li><strong>Code on Demand - </strong>In some cases, the server can extend the functionality of the client by transferring executable code. This is an optional constraint in REST and allows the client to temporarily run code provided by the server to execute certain tasks.</li>
                </ul>
                <h2>REST vs SOAP</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Feature</th>
                                <th>SOAP (Simple Object Access Protocol)</th>
                                <th>REST (Representational State Transfer)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Protocol vs. Style</td>
                                <td>SOAP is a protocol.</td>
                                <td>REST is an architectural style.</td>
                            </tr>
                            <tr>
                                <td>Message Format</td>
                                <td>SOAP uses XML exclusively for message format.</td>
                                <td>REST supports multiple formats, including XML, JSON, HTML, etc.</td>
                            </tr>
                            <tr>
                                <td>Communication</td>
                                <td>SOAP uses HTTP, SMTP, TCP, and more.</td>
                                <td>REST typically uses HTTP/HTTPS for communication.</td>
                            </tr>
                            <tr>
                                <td>State</td>
                                <td>SOAP can be stateful or stateless with added configuration.</td>
                                <td>REST is stateless, meaning each request is independent.</td>
                            </tr>
                            <tr>
                                <td>Performance</td>
                                <td>SOAP is generally slower due to the overhead of XML.</td>
                                <td>REST is faster because it uses lightweight formats like JSON.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="card">
                <h2>Sling Resource Resolution</h2>
                <img src="images/sling-resource-resolution.png" alt="Sling Resource Resolution">
            </div>
        </main>
        <script src="js/script.js"></script>
    </body>
</html>