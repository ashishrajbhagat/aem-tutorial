<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>AEM Tutorial - Authentication and User Management</title>
        <meta name="description" content="Master Adobe Experience Manager (AEM) with our in-depth tutorials, covering AEM components, workflows, servlets, models, Sling, OSGi services, Touch UI dialogs, CRXDE, and more. Perfect for beginners, advanced developers, and AEM architects looking to enhance their skills. Learn how to build scalable and efficient AEM solutions with best practices.">
        <meta name="keywords" content="AEM, Adobe Experience Manager, AEM Tutorial, AEM Training, AEM Components, AEM Workflows, AEM Servlets, AEM Models, AEM Sling, AEM OSGi, AEM Touch UI, AEM CRXDE, AEM DAM, AEM Metadata, AEM Content Fragments, AEM Experience Fragments, AEM Editable Templates, AEM Dispatcher, AEM Forms, AEM Sites, AEM Assets, AEM Cloud, AEM as a Cloud Service, AEM On-Premise, AEM SEO, AEM Best Practices, Learn AEM, AEM Course, AEM Development, AEM Headless, AEM SPA, AEM React, AEM Angular, AEM HTL, AEM Sightly, AEM Frontend, AEM Backend, AEM Workflow Development, AEM Performance Optimization, AEM Interview Questions">
        <meta name="author" content="Ashish Raj">
		<link rel="apple-touch-icon" sizes="180x180" href="../images/favicon/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon/favicon-16x16.png">
        <link rel="manifest" href="/site.webmanifest">
        <link rel="stylesheet" href="../css/styles.css">
    </head>
    <body>
        <div class="sidebar" id="sidebar">
            <div class="logo">
                <h2>AEM Tutorial</h2>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebarSearch" placeholder="🔍 Search..." />
            </div>
            <nav class="nav" id="sidebar-nav"></nav>
            <div class="footer">
                <p>&copy; 2025 AEM Tutorial</p>
            </div>
        </div>
        <span class="hamburger" onclick="toggleMenu()">&#9776;</span>
        <main class="content" id="content">
            <h1>Authentication and User Management</h1>
            <section class="card">
                <h2>Introduction to Security in AEM</h2>
                <p>Security in Adobe Experience Manager (AEM) ensures that only authorized users have access to the right content, tools, and administrative capabilities. Understanding how user and group management works is essential for maintaining a secure and scalable AEM environment.</p>
                <h3>Importance of User and Group Management</h3>
                <ul>
                    <li>Controls who can access specific content or tools within AEM.</li>
                    <li>Supports role-based access control (RBAC) through groups.</li>
                    <li>Improves maintainability and scalability of access permissions.</li>
                    <li>Helps meet compliance and security standards.</li>
                </ul>
                <h3>Authentication vs Authorization in AEM</h3>
                <ul>
                    <li><strong>Authentication:</strong> Verifies a user's identity using credentials like username and password.</li>
                    <li><strong>Authorization:</strong> Determines what actions the authenticated user is allowed to perform based on assigned permissions.</li>
                    <li>Both are essential for protecting content and managing access effectively.</li>
                </ul>
                <h3>Overview of Security Architecture in AEM</h3>
                <ul>
                    <li>Built on Apache Jackrabbit Oak, which handles access control via Access Control Lists (ACLs).</li>
                    <li>Granite Security provides APIs and mechanisms for managing users, groups, and permissions.</li>
                    <li>Supports integration with external identity providers via LDAP, SAML, or OAuth.</li>
                    <li>Security configuration spans the AEM application, repository layer, and external infrastructure (e.g., Dispatcher, web server).</li>
                </ul>
            </section>
            <section class="card">
                <h2>User and Group Management</h2>
                <p>AEM allows you to manage users and groups to enforce security, define access rights, and implement role-based access control. This section explains how to create and manage users and groups using different interfaces.</p>
                <h3>Creating and Managing Users</h3>
                <ul>
                    <li><strong>Creating users via Touch UI (User Admin Console):</strong> Navigate to <code>Tools &gt; Security &gt; Users</code> in AEM. Click "Create" to add a new user, set credentials, and assign group memberships.</li>
                    <li><strong>Creating users via CRXDE Lite:</strong> Go to <code>/home/users</code> and create a new node of type <code>rep:User</code>. Set properties like <code>rep:principalName</code>, <code>rep:password</code>, and <code>rep:authorizableId</code>.</li>
                    <li><strong>User attributes:</strong> Each user has a unique ID, encrypted password, a storage path (like <code>/home/users/a/ashish</code>), and an optional home directory for storing preferences or data.</li>
                </ul>
                <h3>Creating and Managing Groups</h3>
                <ul>
                    <li><strong>Default groups in AEM:</strong> Includes <code>administrators</code>, <code>contributors</code>, <code>content-authors</code>, each with pre-configured access levels.</li>
                    <li><strong>Custom group creation and best practices:</strong> You can create custom groups in Touch UI or CRXDE to define project-specific roles. It's a best practice to assign permissions to groups instead of individual users.</li>
                    <li><strong>Nested groups and inheritance:</strong> Groups can be nested within other groups. Permissions are inherited from parent to child groups, allowing layered access control.</li>
                </ul>
                <h3>Assigning Users to Groups</h3>
                <ul>
                    <li><strong>Role-based access control (RBAC):</strong> Users are assigned to groups that represent specific roles (e.g., authors, reviewers, approvers), and those roles define their access rights.</li>
                    <li><strong>Effective permissions through group assignments:</strong> A user's final access level is the union of all permissions granted to their assigned groups, ensuring flexible yet manageable access control.</li>
                </ul>
            </section>
            <section class="card">
                <h2>Access Control Lists (ACLs)</h2>
                <p>Access Control Lists (ACLs) in AEM define which users or groups can perform specific actions on resources like pages, assets, or nodes in the JCR repository. Proper ACL configuration is critical for securing content and preventing unauthorized access.</p>
                <h3>What is an ACL in AEM?</h3>
                <ul>
                    <li>An ACL is a set of rules applied to a resource (node) that specifies permissions for users or groups.</li>
                    <li>Each ACL entry defines whether a principal (user/group) is allowed or denied specific actions.</li>
                    <li>ACLs are stored as part of the node's access control policies in the repository.</li>
                </ul>
                <h3>Permissions in AEM</h3>
                <ul>
                    <li><strong>Read:</strong> View content or metadata.</li>
                    <li><strong>Modify:</strong> Edit existing content or properties.</li>
                    <li><strong>Create:</strong> Add new nodes or content.</li>
                    <li><strong>Delete:</strong> Remove nodes or content.</li>
                    <li><strong>Replicate:</strong> Publish/unpublish content between author and publish environments.</li>
                    <li><strong>ACL Modify:</strong> Grant or change access control permissions.</li>
                    <li>Permissions can be allowed or denied explicitly and are evaluated in order of specificity.</li>
                </ul>
                <h3>Setting Permissions</h3>
                <ul>
                    <li><strong>Touch UI (Permissions Console):</strong> Navigate to <code>Tools &gt; Security &gt; Permissions</code>, select the path, user/group, and assign permissions visually.</li>
                    <li><strong>CRXDE Lite:</strong> Under node properties, access control entries can be manually edited by setting policies using the Access Control Editor.</li>
                    <li><strong>Useradmin:</strong> Provides a user-focused interface to modify user/group ACLs on specific paths using the classic UI.</li>
                </ul>
                <h3>Inheritance and Overrides in Permission Structures</h3>
                <ul>
                    <li>Permissions set on parent paths can be inherited by child nodes.</li>
                    <li>More specific rules (closer to the resource) override inherited ones.</li>
                    <li>Explicit Deny takes precedence over Allow when both apply to the same action.</li>
                    <li>Conflicts between multiple group memberships are resolved based on path depth and specificity.</li>
                </ul>
                <h3>Best Practices for Fine-Grained Access</h3>
                <ul>
                    <li>Assign permissions to groups, not individual users, for better manageability.</li>
                    <li>Follow least-privilege principle: only grant what's necessary.</li>
                    <li>Avoid modifying ACLs directly under <code>/libs</code>.</li>
                    <li>Use deny rules sparingly and only when essential.</li>
                    <li>Test permissions using test users to validate real-world access.</li>
                </ul>
            </section>
            <section class="card">
                <h2>Authentication Mechanisms in AEM</h2>
                <p>AEM supports multiple authentication mechanisms to ensure that only verified users can access the system. Understanding how authentication works is essential for configuring secure environments across author and publish instances.</p>
                <h3>Default Authentication via JAAS</h3>
                <ul>
                    <li>AEM uses the Java Authentication and Authorization Service (JAAS) framework as the foundation for its authentication mechanisms.</li>
                    <li>JAAS integrates with the underlying repository to authenticate users based on their credentials.</li>
                    <li>Authentication modules (login modules) are pluggable and can support standard or custom login workflows.</li>
                </ul>
                <h3>AEM Login Mechanism (Login Token, Session)</h3>
                <ul>
                    <li>When a user logs in, AEM generates a secure login token that is stored as a cookie in the user's browser.</li>
                    <li>This token is used to authenticate the user across multiple requests without re-entering credentials.</li>
                    <li>A session is created in the repository, tied to the user's identity and permissions.</li>
                    <li>Login tokens are stored in the repository under <code>/home/users</code> as <code>token</code> nodes.</li>
                </ul>
                <h3>Login Token Expiration and Refresh</h3>
                <ul>
                    <li>Login tokens are time-bound and automatically expire after a configurable duration (default: 1 hour).</li>
                    <li>If the session is still active, tokens may be refreshed automatically to avoid logout.</li>
                    <li>Admins can configure token expiration policies under OSGi config: <code>Apache Jackrabbit Oak TokenConfiguration</code>.</li>
                    <li>Expired or unused tokens are cleaned up by a scheduled background job.</li>
                </ul>
                <h3>How Login Works in Different Environments</h3>
                <h4>Author Environment</h4>
                <ul>
                    <li>Typically accessed by internal users like content authors, developers, and admins.</li>
                    <li>Authentication is enforced using AEM's default login form or integrated SSO (e.g., SAML).</li>
                    <li>Users must have valid credentials and appropriate permissions to log in.</li>
                </ul>
                <h4>Publish Environment</h4>
                <ul>
                    <li>Generally does not require user login for public-facing websites.</li>
                    <li>If login is needed (e.g., for gated content or personalization), it uses the same login token mechanism.</li>
                    <li>Authentication can be integrated with SSO or external IDPs to allow secure frontend user access.</li>
                    <li>Always validate input and avoid exposing admin interfaces on publish.</li>
                </ul>
            </section>
            <section class="card">
                <h2>Authentication Handlers (Login Modules)</h2>
                <p>Authentication Handlers, also known as Login Modules in AEM, define how user credentials are validated and how authentication is performed. AEM supports various built-in handlers and allows custom implementations to integrate with different identity providers.</p>
                <h3>What are Login Modules in AEM?</h3>
                <ul>
                    <li>Login Modules are part of the JAAS-based authentication framework used by AEM.</li>
                    <li>They control how login requests are processed and whether a user is authenticated successfully.</li>
                    <li>Each authentication handler supports a specific mechanism like form-based login, SAML, OAuth, or LDAP.</li>
                    <li>They are configurable via OSGi and can be prioritized based on login path or domain.</li>
                </ul>
                <h3>Adobe Granite Login Selector Authentication Handler</h3>
                <ul>
                    <li>Used for selecting the appropriate authentication handler based on the request path or host.</li>
                    <li>Enables support for multiple authentication methods within the same AEM instance.</li>
                    <li>Commonly used when supporting internal (author) and external (SSO) login methods simultaneously.</li>
                </ul>
                <h3>Adobe Granite OAuth Authentication Handler</h3>
                <ul>
                    <li>Allows integration with OAuth 2.0-based identity providers such as Adobe IMS, Google, or Facebook.</li>
                    <li>Users authenticate using an external OAuth flow, and AEM maps the identity to a local user.</li>
                    <li>Configured via the <code>Adobe Granite OAuth Authentication Handler</code> OSGi config.</li>
                    <li>Supports scopes, client secrets, and redirect URIs for complete OAuth setup.</li>
                </ul>
                <h3>SAML 2.0 Authentication Handler</h3>
                <ul>
                    <li>Enables Single Sign-On (SSO) by integrating with enterprise identity providers using SAML 2.0.</li>
                    <li>Commonly used in corporate environments for secure access to AEM Author and Publish instances.</li>
                    <li>Maps SAML assertions to AEM users and groups dynamically or statically.</li>
                    <li>Configured via the <code>Adobe Granite SAML 2.0 Authentication Handler</code>.</li>
                </ul>
                <h3>LDAP Authentication Handler</h3>
                <ul>
                    <li>Supports authentication against LDAP or Active Directory servers.</li>
                    <li>Allows external user synchronization into AEM with group mapping.</li>
                    <li>Often used in internal authoring environments with corporate identity systems.</li>
                    <li>Configured via OSGi: <code>Apache Jackrabbit Oak LDAP Identity Provider</code> and related configs.</li>
                </ul>
                <h3>Custom Authentication Handlers</h3>
                <ul>
                    <li>Custom handlers can be developed by implementing the <code>AuthenticationHandler</code> or extending built-in modules.</li>
                    <li>Useful when integrating with proprietary or uncommon authentication flows.</li>
                    <li>Must be registered as OSGi components with the appropriate path filters and priorities.</li>
                    <li>Care must be taken to ensure they are secure, efficient, and properly tested.</li>
                </ul>
            </section>
            <section class="card">
                <h2>External Identity Providers</h2>
                <p>AEM can integrate with enterprise identity systems such as LDAP, Active Directory, SAML 2.0, and OAuth2 to support centralized authentication and user management. This helps maintain consistency, improve security, and enable single sign-on (SSO) across enterprise applications.</p>
                <h3>LDAP/Active Directory Integration</h3>
                <ul>
                    <li>Enables authentication and user synchronization from LDAP-based directories such as Microsoft Active Directory.</li>
                    <li>Configured using the <code>Apache Jackrabbit Oak LDAP Identity Provider</code> and related OSGi configs.</li>
                    <li>Allows automatic user and group sync into AEM based on LDAP filters and attributes.</li>
                    <li>Supports periodic sync or sync-on-login strategies.</li>
                    <li>Typically used for AEM Author instance where corporate users require access.</li>
                </ul>
                <h3>SAML 2.0 Integration</h3>
                <ul>
                    <li>Provides support for federated authentication using enterprise Identity Providers (IdPs) like Okta, Azure AD, Ping Identity, etc.</li>
                    <li>Configured via the <code>Adobe Granite SAML 2.0 Authentication Handler</code> OSGi config.</li>
                    <li>SSO is achieved by exchanging SAML assertions with the IdP, which AEM validates to authenticate users.</li>
                    <li>Supports automatic creation of AEM users based on SAML attributes (e.g., email, groups).</li>
                    <li>Works well in both Author and Publish environments for secure user access.</li>
                </ul>
                <h3>OAuth2 with Adobe IMS or Other Identity Providers</h3>
                <ul>
                    <li>Integrates AEM with identity providers using the OAuth 2.0 protocol (e.g., Adobe IMS, Google, Azure AD, Facebook).</li>
                    <li>Configured via <code>Adobe Granite OAuth Authentication Handler</code> OSGi config.</li>
                    <li>Uses standard OAuth flow: authorization code exchange, access token, and optional refresh token.</li>
                    <li>Useful for allowing social login or third-party system access.</li>
                </ul>
                <h3>Synchronization of External Users/Groups</h3>
                <ul>
                    <li>External identities are mapped to local AEM users and groups using <code>ExternalLoginModule</code> and sync handlers.</li>
                    <li>Sync handler configurations control how user attributes and memberships are handled during login or scheduled sync.</li>
                    <li>Supports automatic group assignment, profile property mapping, and user deactivation strategies.</li>
                    <li>Synced users are typically stored under <code>/home/users</code> with metadata about their origin.</li>
                </ul>
                <h3>Trust-Based Authentication via Headers (SSO, Dispatcher Filters)</h3>
                <ul>
                    <li>Enables SSO by trusting headers (like <code>x-forwarded-user</code>) passed by a trusted frontend proxy or SSO system.</li>
                    <li>AEM must be configured to trust these headers only when coming from secure and validated sources (e.g., via Dispatcher).</li>
                    <li>Used in high-security deployments where authentication is handled entirely upstream (e.g., Apache HTTP Server or load balancer).</li>
                    <li>Requires custom or extended <code>AuthenticationHandler</code> to map headers to AEM sessions.</li>
                </ul>
            </section>
            <section class="card">
                <h2>Granite Security APIs</h2>
                <p>AEM provides a set of Granite and JCR-based security APIs that allow developers to manage users, groups, and access control programmatically. These APIs are useful for custom provisioning workflows, automation scripts, or enforcing access policies during runtime.</p>
                <h3>Overview of Security APIs in AEM</h3>
                <ul>
                    <li>Granite Security APIs are built on top of the JCR (Jackrabbit Oak) and are accessible via Sling and Java interfaces.</li>
                    <li>They offer capabilities to manage authorizables (users and groups), set permissions, and evaluate access rights.</li>
                    <li>Main interfaces include <code>UserManager</code>, <code>Authorizable</code>, <code>Group</code>, and <code>AccessControlManager</code>.</li>
                    <li>Available via service user/resource resolver or JCR session in backend logic (e.g., Sling Servlets, Workflow steps).</li>
                </ul>
                <h3>Programmatic Operations</h3>
                <ul>
                    <li>
                        <strong>Create/Delete Users and Groups:</strong>
                        <ul>
                            <li>Use <code>UserManager.createUser()</code> and <code>createGroup()</code> to create new authorizables.</li>
                            <li>Use <code>removeAuthorizable()</code> to delete users or groups safely.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Assign Permissions:</strong>
                        <ul>
                            <li>Obtain <code>AccessControlManager</code> via JCR session.</li>
                            <li>Use <code>AccessControlList</code> to define and set privileges like <code>jcr:read</code>, <code>jcr:write</code>, etc.</li>
                            <li>Apply policies using <code>AccessControlManager.setPolicy()</code>.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Check Access Rights:</strong>
                        <ul>
                            <li>Use <code>Session.hasPermission()</code> or <code>AccessControlManager.hasPrivileges()</code> to check user access on a path.</li>
                            <li>Helps in building secure logic in servlets or filters.</li>
                        </ul>
                    </li>
                </ul>
                <h3>Example API Classes</h3>
                <ul>
                    <li><code>UserManager</code>: Used to manage users and groups.</li>
                    <li><code>Authorizable</code>: Base interface for both users and groups.</li>
                    <li><code>Group</code>: Extends <code>Authorizable</code>, provides group-specific operations like <code>addMember()</code>.</li>
                    <li><code>AccessControlManager</code>: Used to define, retrieve, and manage ACLs on repository nodes.</li>
                </ul>
                <p><strong>Note:</strong> Always use service users and properly scoped resource resolvers when accessing these APIs to follow security best practices.</p>
            </section>
            <section class="card">
                <h2>Audit & User Session Management</h2>
                <p>AEM provides tools and logs to track user sessions and audit login activities. Monitoring user behavior and session lifecycles is crucial for identifying unauthorized access, session misuse, or brute-force login attempts.</p>
                <h3>Session Tracking and Audit Logs</h3>
                <ul>
                    <li>User login and logout events are recorded in AEM's audit log files (<code>audit.log</code>), located under <code>/crx-quickstart/logs</code>.</li>
                    <li>Each event includes timestamp, user ID, IP address, and event type (login, logout, failed attempt).</li>
                    <li>Useful for compliance tracking and security audits.</li>
                    <li>Can be integrated with external SIEM/log monitoring tools for real-time alerts.</li>
                </ul>
                <h3>Viewing Active User Sessions</h3>
                <ul>
                    <li>Active sessions are managed via login tokens stored under <code>/home/users</code>.</li>
                    <li>You can use the <strong>TokenCleanupTask</strong> or write custom scripts to list active sessions.</li>
                    <li>Login tokens can be examined or revoked manually through CRXDE Lite if needed.</li>
                    <li>No out-of-the-box session viewer UI, but session info can be extracted programmatically via JCR or JMX.</li>
                </ul>
                <h3>Logging Out a Session Manually</h3>
                <ul>
                    <li>Manually delete the corresponding token node under <code>/home/users/.../tokens</code> to force logout.</li>
                    <li>Use custom servlet or script to perform secure token invalidation.</li>
                    <li>Can also be handled via JMX or custom admin tools in enterprise environments.</li>
                </ul>
                <h3>Detecting Brute-Force Login Attempts</h3>
                <ul>
                    <li>Repeated failed login attempts are logged in <code>error.log</code> or <code>audit.log</code> with user ID and IP address.</li>
                    <li>Use log analysis or monitoring tools (e.g., Splunk, ELK) to detect suspicious patterns.</li>
                    <li>Consider implementing account lockout mechanisms via custom authentication handlers.</li>
                    <li>Limit login attempts via Dispatcher rules or web application firewalls (WAF).</li>
                </ul>
            </section>
            <section class="card">
                <h2>Password Policies and Security Settings</h2>
                <p>To ensure secure authentication, AEM supports various password policies and system-level settings that control session management and login behavior. These settings help protect against unauthorized access, session hijacking, and brute-force attacks.</p>
                <h3>Password Complexity Requirements</h3>
                <ul>
                    <li>By default, AEM does not enforce strong password policies, but you can configure custom validators using backend logic or identity provider rules.</li>
                    <li>
                        Best practices recommend enforcing:
                        <ul>
                            <li>Minimum length (e.g., 8+ characters)</li>
                            <li>At least one uppercase, lowercase, number, and special character</li>
                            <li>Restrictions on previously used passwords</li>
                        </ul>
                    </li>
                    <li>For enterprise environments, enforce password policies via LDAP/SSO providers.</li>
                </ul>
                <h3>Session Timeout Settings</h3>
                <ul>
                    <li>Session timeout can be configured via the OSGi config: <code>Apache Jackrabbit Oak TokenConfiguration</code>.</li>
                    <li>Default timeout is 1 hour of inactivity; tokens expire automatically afterward.</li>
                    <li>You can adjust timeout using the <code>Token Expiration</code> property (in seconds).</li>
                    <li>Shorter timeouts improve security but may affect authoring UX.</li>
                </ul>
                <h3>Token Cleanup Job</h3>
                <ul>
                    <li>Old or expired login tokens are cleaned up automatically by the <strong>TokenCleanupTask</strong> background job.</li>
                    <li>Configured via OSGi: <code>Adobe Granite Token Cleanup Task</code>.</li>
                    <li>Prevents token buildup under <code>/home/users</code>, which could otherwise lead to performance degradation.</li>
                    <li>You can configure the cleanup frequency and batch size.</li>
                </ul>
                <h3>Account Lockout Policies</h3>
                <ul>
                    <li>By default, AEM does not lock accounts after failed attempts, but you can implement custom login modules to enforce this.</li>
                    <li>In enterprise environments, use SSO/LDAP providers that support lockout after N failed logins.</li>
                    <li>Alternatively, monitor <code>audit.log</code> for brute-force attempts and integrate with intrusion detection tools.</li>
                    <li>Some custom solutions involve setting a user property (e.g., <code>locked=true</code>) and blocking logins programmatically.</li>
                </ul>
            </section>
            <section class="card">
                <h2>Controlling Access to Assets and Content</h2>
                <p>AEM allows you to secure assets and pages based on user roles and permissions. Proper control over content visibility is essential in multi-user authoring environments or when delivering role-specific experiences on publish instances.</p>
                <h3>Asset-Level Permissions (e.g., /content/dam)</h3>
                <ul>
                    <li>Permissions can be applied to folders and assets under <code>/content/dam</code> using the Permissions Console or CRXDE Lite.</li>
                    <li>
                        Common use cases:
                        <ul>
                            <li>Restrict access to confidential documents or media assets.</li>
                            <li>Limit upload/delete access to specific groups (e.g., <code>asset-admins</code>).</li>
                            <li>Assign read-only access for reviewers or business users.</li>
                        </ul>
                    </li>
                    <li>Permissions cascade down the folder hierarchy unless overridden.</li>
                </ul>
                <h3>Restricting Content Pages Based on User Roles</h3>
                <ul>
                    <li>Set ACLs on content paths like <code>/content/site</code> to control who can view, edit, or publish pages.</li>
                    <li>Use group-based access (e.g., <code>marketing-authors</code>, <code>finance-authors</code>) for page-level restrictions.</li>
                    <li>
                        On publish, restrict access to specific pages using:
                        <ul>
                            <li>Login-based protection with authentication handlers.</li>
                            <li>Dispatcher filters or URL-level rules.</li>
                            <li>Secure areas of the site with SAML or OAuth authentication.</li>
                        </ul>
                    </li>
                </ul>
                <h3>Dynamic Content Control Using UserProperties or SlingBindings</h3>
                <ul>
                    <li>Display or hide specific content blocks based on the logged-in user's profile.</li>
                    <li>Use <code>${currentUser}</code> or Sling Bindings in HTL to access user properties dynamically.</li>
                    <li>
                        Common dynamic checks:
                        <ul>
                            <li>User role or group membership</li>
                            <li>Custom user attributes (e.g., department, region)</li>
                        </ul>
                    </li>
                    <li>Use these methods in components to personalize content without full AEM Personalization.</li>
                </ul>
            </section>
            <section class="card">
                <h2>Programmatic Access Control Management</h2>
                <p>In some advanced use cases, user and permission management needs to be automated via backend logic. AEM provides APIs to create users, groups, and ACLs programmatically through servlets, workflow steps, or services.</p>
                <h3>Creating Users/Groups via Backend Logic</h3>
                <ul>
                    <li>Use AEM's <code>UserManager</code> and <code>Group</code> APIs to create and manage users/groups.</li>
                    <li>
                        Common integration points:
                        <ul>
                            <li>Sling Servlets for custom admin tools</li>
                            <li>Workflow Process Steps for provisioning during onboarding flows</li>
                            <li>OSGi Services or Sling Models for system-driven user creation</li>
                        </ul>
                    </li>
                    <li>Always perform such actions using a properly scoped service user.</li>
                </ul>
                <h3>Managing ACLs via Code</h3>
                <ul>
                    <li>Use <code>AccessControlManager</code> to add, modify, or remove access control policies on repository paths.</li>
                    <li>Define privileges (e.g., <code>jcr:read</code>, <code>jcr:write</code>, <code>jcr:modifyAccessControl</code>) for specific principals.</li>
                    <li>Set or remove ACLs via methods like <code>addAccessControlEntry()</code> and <code>setPolicy()</code>.</li>
                </ul>
                <h3>Example Use Cases</h3>
                <ul>
                    <li>Auto-create an author user and assign them to a project group during a site creation workflow.</li>
                    <li>Restrict access to a secured page immediately after publishing it via workflow.</li>
                    <li>Batch script to update permissions across a large content hierarchy.</li>
                </ul>
                <h3>Sample Code Snippet (Java)</h3>
                <pre>// Example: Creating a user
UserManager userManager = resourceResolver.adaptTo(UserManager.class);
User user = userManager.createUser("newuser", "password123");

// Assigning group
Group group = (Group) userManager.getAuthorizable("content-authors");
group.addMember(user);
resourceResolver.commit();</pre>
            </section>
            <section class="card">
                <h2>Testing and Debugging Permissions</h2>
                <p>After configuring ACLs, it's important to verify that they are working as expected. AEM provides several tools and methods to test and debug permission-related issues.</p>
                <h3>How to Test if ACLs Are Working Properly</h3>
                <ul>
                    <li>Create a test user or use impersonation to check access to content or tools.</li>
                    <li>Try accessing pages or assets with restricted permissions to validate results.</li>
                    <li>Ensure permission inheritance behaves correctly by checking child nodes.</li>
                </ul>
                <h3>Tools for Testing and Debugging</h3>
                <ul>
                    <li><strong>Permissions Console:</strong> Visual tool to view and modify user/group permissions.</li>
                    <li><strong>CRXDE Lite:</strong> Check ACL entries at the JCR node level under <code>rep:policy</code>.</li>
                    <li><strong>curl:</strong> Test HTTP access using basic auth to verify if user can reach a resource.</li>
                    <li><strong>Logs:</strong> Use <code>error.log</code> and <code>audit.log</code> to detect denied access or login failures.</li>
                </ul>
                <h3>Common Issues and Fixes</h3>
                <ul>
                    <li><strong>Accidentally locked out:</strong> Always keep a backup admin user with full access.</li>
                    <li><strong>Permissions not applying:</strong> Check for path-level overrides or inherited denies.</li>
                    <li><strong>Multiple group conflicts:</strong> Deny overrides allow; use hierarchy and test users to isolate.</li>
                    <li><strong>Access from publish not working:</strong> Ensure user is properly created and replicated if needed, and not blocked by Dispatcher filters.</li>
                </ul>
            </section>
            <section class="card">
                <h2>AEM and Dispatcher Level Security</h2>
                <p>The AEM Dispatcher acts as the first line of defense for your publish environment. Properly configuring Dispatcher rules is essential to prevent unauthorized access to sensitive paths and APIs.</p>
                <h3>Dispatcher Filters and <code>/filter</code> <code>/allow</code> Rules</h3>
                <ul>
                    <li>The <code>/filter</code> section of the <code>dispatcher.any</code> file defines what requests are allowed or denied.</li>
                    <li>Always follow deny-by-default and explicitly allow only required paths.</li>
                    <li>
                        Commonly allowed paths include:
                        <ul>
                            <li><code>/content</code> - for public-facing pages</li>
                            <li><code>/etc.clientlibs</code> - for client libraries</li>
                            <li><code>/libs/granite/csrf/token.json</code> - for CSRF token</li>
                        </ul>
                    </li>
                    <li>
                        Block dangerous paths such as:
                        <ul>
                            <li><code>/bin</code>, <code>/apps</code>, <code>/libs</code>, <code>/crx</code>, <code>/system</code></li>
                        </ul>
                    </li>
                    <li>Use the <code>glob</code> pattern to fine-tune access and add logging during development to validate filter hits.</li>
                </ul>
                <h3>Securing /libs, /apps, /bin, and /crx</h3>
                <ul>
                    <li>These paths expose internal APIs, authoring tools, or sensitive data.</li>
                    <li>They should never be accessible from the publish instance or internet-facing Dispatcher.</li>
                    <li>Ensure these are explicitly blocked in the Dispatcher filter rules and tested.</li>
                </ul>
                <h3>Authenticating at Dispatcher Level with SSO Headers</h3>
                <ul>
                    <li>In some enterprise deployments, authentication is offloaded to an upstream SSO system.</li>
                    <li>Dispatcher can be configured to accept headers like <code>x-forwarded-user</code> from a trusted proxy.</li>
                    <li>Use this only in secure environments where the proxy is fully controlled and trusted.</li>
                    <li>Never allow direct access to publish ports bypassing Dispatcher.</li>
                </ul>
            </section>
            <section class="card">
                <h2>SSL and Secure Login (See Deployment & Security Section)</h2>
                <p><em>Note:</em> For detailed information on implementing SSL and secure login, <a href="ssl-secure-login.html"><strong>read more here</strong></a>.</p>
                <ul>
                    <li>AEM expects secure communication over HTTPS, especially for logins and authoring activities.</li>
                    <li>SSL/TLS termination is typically handled at the Dispatcher or external web server (e.g., Apache HTTPD, NGINX).</li>
                    <li>Use strong TLS protocols and ensure HTTP is redirected to HTTPS.</li>
                    <li>Set <code>secure</code> and <code>HttpOnly</code> flags on login cookies to prevent session hijacking.</li>
                </ul>
            </section>
            <section class="card">
                <h2>Best Practices</h2>
                <p>To ensure your AEM instance remains secure, scalable, and maintainable, follow these essential best practices when working with authentication, users, groups, and permissions.</p>
                <ul>
                    <li><strong>Never modify permissions under <code>/libs</code>:</strong> This path contains core AEM functionality. Modifying it can break features and complicate upgrades. Instead, manage access at <code>/apps</code>, <code>/content</code>, or <code>/conf</code>.</li>
                    <li><strong>Use groups over individual user assignments:</strong> Assigning permissions to groups makes user management simpler, enforces RBAC principles, and prevents permission sprawl.</li>
                    <li><strong>Always test ACLs with test users:</strong> Don't assume configurations work — impersonate or use test accounts to verify access to pages, assets, and tools.</li>
                    <li><strong>Avoid over-permissive group settings:</strong> Groups like <code>everyone</code> or <code>all-authors</code> should be tightly scoped. Grant only necessary permissions to minimize security risks.</li>
                    <li><strong>Document and review permissions regularly:</strong> Periodic audits help ensure users and groups have appropriate access and that legacy permissions are cleaned up.</li>
                </ul>
            </section>
            <script src="https://utteranc.es/client.js" repo="ashishrajbhagat/aem-tutorial" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
        </main>
        <script src="../js/script.js"></script>
    </body>
</html>