<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>AEM Tutorial - Models</title>
        <meta name="description" content="Master Adobe Experience Manager (AEM) with our in-depth tutorials, covering AEM components, workflows, servlets, models, Sling, OSGi services, Touch UI dialogs, CRXDE, and more. Perfect for beginners, advanced developers, and AEM architects looking to enhance their skills. Learn how to build scalable and efficient AEM solutions with best practices.">
        <meta name="keywords" content="AEM, Adobe Experience Manager, AEM Tutorial, AEM Training, AEM Components, AEM Workflows, AEM Servlets, AEM Models, AEM Sling, AEM OSGi, AEM Touch UI, AEM CRXDE, AEM DAM, AEM Metadata, AEM Content Fragments, AEM Experience Fragments, AEM Editable Templates, AEM Dispatcher, AEM Forms, AEM Sites, AEM Assets, AEM Cloud, AEM as a Cloud Service, AEM On-Premise, AEM SEO, AEM Best Practices, Learn AEM, AEM Course, AEM Development, AEM Headless, AEM SPA, AEM React, AEM Angular, AEM HTL, AEM Sightly, AEM Frontend, AEM Backend, AEM Workflow Development, AEM Performance Optimization, AEM Interview Questions">
        <meta name="author" content="Ashish Raj">
        <link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png">
        <link rel="manifest" href="/site.webmanifest">
        <link rel="stylesheet" href="css/styles.css">
    </head>
    <body>
        <div class="sidebar" id="sidebar">
            <div class="logo">
                <h2>AEM Tutorial</h2>
            </div>
            <nav class="nav">
                <ul class="nav-list" id="navList"></ul>
            </nav>
            <div class="footer">
                <p>&copy; 2025 AEM Tutorial</p>
            </div>
        </div>
        <span class="hamburger" onclick="toggleMenu()">&#9776;</span>
        <main class="content" id="content">
            <h1>Models</h1>
            <div class="card">
                <h2>Introduction to Models in AEM</h2>
                <p>Models in AEM help structure backend logic and data so that it can be easily accessed and rendered in the front-end using HTL. They provide a clean way to separate data processing from presentation, making AEM development more efficient and maintainable.</p>
                <h3>What is a Sling Model?</h3>
                <p>A Sling Model is a Java class annotated to adapt Sling resources or requests into a simple Java object (POJO). It allows developers to define properties and methods that represent the underlying content or business logic, which can then be used directly in HTL templates.</p>  
                <h3>Importance of Models in AEM development</h3>
                <p>Models are crucial in AEM development because they:</p>
                <ul>
                    <li>Promote a clear separation between backend logic and front-end presentation.</li>
                    <li>Enable reuse of business logic across multiple components or pages.</li>
                    <li>Enhance maintainability by encapsulating resource access and processing in one place.</li>
                    <li>Support clean, readable, and secure front-end code by reducing logic inside HTL.</li>
                </ul>
            </div>
            <div class="card">
                <h2>Sling Models Overview</h2>
                <p>Sling Models provide a flexible and standardized way to create Java objects that adapt Sling resources or requests. They simplify accessing and manipulating content stored in the JCR repository by mapping properties and services directly to Java classes.</p>
                <h3>Anatomy of a Sling Model</h3>
                <p>A typical Sling Model includes the following parts:</p>
                <ul>
                    <li><code>@Model</code> annotation that defines the adaptable types like <code>Resource</code> or <code>SlingHttpServletRequest</code>.</li>
                    <li>Field injection using <code>@Inject</code> or <code>@ValueMapValue</code> to obtain resource properties or OSGi services.</li>
                    <li>Getter methods to expose properties and business logic to HTL.</li>
                    <li>Optional lifecycle callback methods like <code>@PostConstruct</code> for initialization.</li>
                </ul>
                <h3>How Sling Models simplify backend logic for HTL</h3>
                <p>Sling Models abstract the complexity of interacting directly with the JCR repository or Sling APIs by providing clean Java objects with ready-to-use properties and methods. This allows HTL templates to focus solely on presentation without embedding complex Java code or business logic.</p>
            </div>
            <div class="card">
                <h2>Creating a Sling Model</h2>
                <p>Creating a Sling Model involves defining a Java class that adapts Sling resources or requests, allowing backend data and logic to be exposed cleanly to HTL templates.</p>
                <h3>Basic steps to create a Sling Model</h3>
                <ul>
                    <li>Create a Java class in your AEM project under an appropriate package.</li>
                    <li>Annotate the class with <code>@Model</code> specifying the adaptable classes such as <code>Resource</code> or <code>SlingHttpServletRequest</code>.</li>
                    <li>Inject properties from the JCR or OSGi services into fields using annotations like <code>@Inject</code> or <code>@ValueMapValue</code>.</li>
                    <li>Implement getter methods to expose these injected values to HTL.</li>
                    <li>Optionally, add <code>@PostConstruct</code> method for initialization logic.</li>
                </ul>
                <h3>Annotations used in Sling Models (@Model, @Inject, @ValueMapValue)</h3>
                <ul>
                    <li><code>@Model</code>: Marks the class as a Sling Model and defines the adaptable types.</li>
                    <li><code>@Inject</code>: Injects Sling objects or services such as <code>ResourceResolver</code>, <code>SlingHttpServletRequest</code>, or OSGi services.</li>
                    <li><code>@ValueMapValue</code>: Injects properties from the JCR node or resource's value map, often used for component content properties.</li>
                </ul>
            </div>              
            <div class="card">
                <h2>Injecting Resources and Request Objects</h2>
                <p>In Sling Models, injecting Sling resources and request objects enables developers to access the content repository and request details easily within the model, allowing more dynamic and context-aware backend logic.</p>
                <h3>Using @Inject for Sling Resources and Services</h3>
                <p>The <code>@Inject</code> annotation is used to inject Sling objects such as <code>Resource</code>, <code>ResourceResolver</code>, or OSGi services directly into the Sling Model. This allows the model to work with the underlying repository content or perform service operations.</p>
                <h3>Injecting SlingHttpServletRequest and ResourceResolver</h3>
                <p>By injecting <code>SlingHttpServletRequest</code>, the model gains access to request-specific information like request parameters and headers. Injecting <code>ResourceResolver</code> allows interaction with the JCR repository for reading or writing content.</p>
                <ul>
                    <li><code>@Inject private SlingHttpServletRequest request;</code> - Access HTTP request data.</li>
                    <li><code>@Inject private ResourceResolver resourceResolver;</code> - Access the JCR repository to fetch or modify resources.</li>
                </ul>
            </div>
            <div class="card">
                <h2>Property Injection</h2>
                <p>Property injection in Sling Models allows you to map properties from JCR nodes directly to Java class fields. This makes it easy to retrieve component dialog values or page properties without writing extra boilerplate code.</p>
                <h3>Using @ValueMapValue for injecting JCR properties</h3>
                <p>The <code>@ValueMapValue</code> annotation is used to inject values from the JCR ValueMap (i.e., properties on the underlying resource). It is most commonly used for component dialog fields.</p>
                <ul>
                    <li><code>@ValueMapValue</code> looks for a property on the resource and injects it into the model field.</li>
                    <li>It works only when the model is adapted from a <code>Resource</code> or <code>SlingHttpServletRequest</code> that resolves to a resource.</li>
                    <li>Example: <code>@ValueMapValue private String title;</code></li>
                </ul>              
                <h3>Optional vs required properties</h3>
                <p>By default, all properties injected using <code>@ValueMapValue</code> are optional. If the property does not exist, the injected value will be <code>null</code>. To make a property required, use <code>@Inject</code> with <code>@Required</code>.</p>
                <ul>
                    <li>Optional (default): <code>@ValueMapValue private String subtitle;</code></li>
                    <li>Required: <code>@Inject @Required private String title;</code> - will throw an error if <code>title</code> is missing</li>
                    <li>You can also use <code>@Default</code> to provide a fallback value for optional fields.</li>
                </ul>
            </div>
            <div class="card">
                <h2>Adaptables in Sling Models</h2>
                <p>Adaptables define the source from which a Sling Model is created. They determine what context the model is operating in and how dependencies like properties and request objects are injected. The two most common adaptables in AEM are <code>Resource</code> and <code>SlingHttpServletRequest</code>.</p>
                <h3>What can Sling Models adapt from?</h3>
                <p>Sling Models can be adapted from:</p>
                <ul>
                  <li><strong>Resource</strong> - Most common. Used when you want to access content properties from a JCR node.</li>
                  <li><strong>SlingHttpServletRequest</strong> - Used when request-specific data or context is needed, such as query parameters or request attributes.</li>
                  <li><strong>Other objects</strong> - Like <code>SlingBindings</code>, but these are less common and used in more advanced scenarios.</li>
                </ul>
                <h3>When to use which adaptable</h3>
                <ul>
                  <li><strong>Use <code>Resource</code></strong> - When you only need to access properties from a JCR node (like in most component models).</li>
                  <li><strong>Use <code>SlingHttpServletRequest</code></strong> - When you need access to request-specific objects, dynamic data, or when the model is used in a request context (e.g., with <code>data-sly-use</code> in HTL).</li>
                  <li><strong>Note:</strong> If adapted from <code>SlingHttpServletRequest</code>, you still get access to the underlying resource using <code>@Inject private Resource resource;</code></li>
                </ul>
            </div>
            <div class="card">
                <h2>Using @PostConstruct for Initialization</h2>
                <p>The <code>@PostConstruct</code> annotation in Sling Models is used to mark a method that should be executed after all dependency injections are completed. This is useful for performing initialization logic, setting default values, or computing derived fields.</p>
                <h3>Lifecycle methods in Sling Models</h3>
                <p>Sling Models support a basic lifecycle where dependencies are injected first, and then a method annotated with <code>@PostConstruct</code> is executed. This ensures that all injected fields are available for use during initialization.</p>
                <ul>
                    <li><code>@PostConstruct</code> method must be <code>public</code> or <code>protected</code> and return <code>void</code>.</li>
                    <li>Used to initialize computed fields or validate input data.</li>
                    <li>Only one method per model class should be annotated with <code>@PostConstruct</code>.</li>
                </ul>  
                <h3>Best practices for initialization logic</h3>
                <ul>
                    <li>Keep the method clean and focused only on initializing logic based on injected values.</li>
                    <li>Avoid complex business logic or long-running operations inside <code>@PostConstruct</code>.</li>
                    <li>Use <code>@PostConstruct</code> to ensure fallback/default values are applied if properties are missing.</li>
                    <li>Name the method something meaningful, like <code>init()</code> or <code>setup()</code>, even though the name isn't enforced.</li>
                </ul>
            </div>
            <div class="card">
                <h2>Exporting Sling Models as JSON</h2>
                <p>Sling Models can be exposed as JSON using the <code>@Exporter</code> annotation. This allows AEM components to serve data to front-end applications, making it easy to build headless or SPA (Single Page Application) experiences.</p>
                <h3>Using the @Exporter annotation</h3>
                <p>The <code>@Exporter</code> annotation is used to serialize a Sling Model into a specific format like JSON. The most common exporter is <code>jackson</code>, which uses the Jackson library for JSON output.</p>
                <ul>
                    <li>Add <code>@Exporter(name = "jackson", extensions = "json")</code> to your Sling Model class.</li>
                    <li>Ensure all fields you want to expose are public or have public getters.</li>
                    <li>You can use <code>@JsonIgnore</code> to exclude fields and <code>@JsonProperty</code> to rename fields.</li>
                </ul>  
                <h3>Creating RESTful APIs with Sling Models</h3>
                <p>Once a Sling Model is exported using <code>jackson</code>, it becomes accessible via a simple URL endpoint ending in <code>.model.json</code>.</p>
                <ul>
                    <li>Example URL: <code>/content/mysite/home.model.json</code></li>
                    <li>This serves the JSON representation of the Sling Model associated with that resource.</li>
                    <li>Great for integrating AEM with front-end frameworks like React, Angular, or Vue.</li>
                    <li>Can be combined with Sling Selectors, Filters, and custom servlets for building full REST APIs.</li>
                </ul>
            </div>
            <div class="card">
                <h2>Annotations Used in Sling Models</h2>
                <p>Sling Models utilize various annotations to facilitate resource adaptation, injection, lifecycle handling, and JSON exporting. Knowing these annotations helps create clean, maintainable, and efficient models.</p>
                <ul>
                    <li><strong>@Model</strong>: Declares the class as a Sling Model and specifies adaptable types (e.g., Resource, SlingHttpServletRequest), default injection strategy, and optional resourceType.</li>
                    <li><strong>@Inject</strong>: Injects Sling objects, properties, or services into model fields.</li>
                    <li><strong>@ValueMapValue</strong>: Injects JCR property values from the resource's ValueMap.</li>
                    <li><strong>@Self</strong>: Injects the adaptable object itself (Resource or SlingHttpServletRequest).</li>
                    <li><strong>@OSGiService</strong>: Injects an OSGi service instance.</li>
                    <li><strong>@PostConstruct</strong>: Marks a method to run after all injections, for initialization logic.</li>
                    <li><strong>@Exporter</strong>: Enables Sling Model JSON or other format exporting, specifying exporter type and extension.</li>
                    <li><strong>@JsonIgnore</strong>: (Jackson) Excludes a field or method from JSON serialization.</li>
                    <li><strong>@JsonProperty</strong>: (Jackson) Specifies custom JSON property names for methods or fields.</li>
                    <li><strong>@Optional</strong>: Marks an injection as optional (legacy; replaced by defaultInjectionStrategy).</li>
                    <li><strong>@Named</strong>: Specifies an alternative name for the property to inject, if different from the field name.</li>
                    <li><strong>@Default</strong>: Provides a default value if the injected property is missing.</li>
                    <li><strong>@Via</strong>: Customizes the injection source path, for example injecting from a child node.</li>
                    <li><strong>@ScriptVariable</strong>: Injects variables available from the scripting context, such as page or resourceResolver.</li>
                    <li><strong>@SlingObject</strong>: Injects Sling framework objects like ResourceResolver or SlingScriptHelper.</li>
                    <li><strong>@DefaultInjectionStrategy</strong>: Applied at the class level to control whether injections are optional or required by default.</li>
                </ul>                  
                <h3>Example of a Simple Sling Model</h3>
                <p>This example shows a Sling Model adapted from <code>Resource</code> and <code>SlingHttpServletRequest</code>, using annotations like <code>@Inject</code>, <code>@ValueMapValue</code>, <code>@Self</code>, <code>@PostConstruct</code>, <code>@OSGiService</code>, and JSON export annotations.</p>
<pre>package com.example.aem.models;

import javax.annotation.PostConstruct;
import javax.inject.Inject;
import javax.inject.Named;

import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.scripting.SlingScriptHelper;
import org.apache.sling.api.sling.Http.SlingHttpServletRequest;

import org.apache.sling.models.annotations.Model;
import org.apache.sling.models.annotations.DefaultInjectionStrategy;
import org.apache.sling.models.annotations.injectorspecific.*;
import org.apache.sling.models.annotations.Exporter;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;

@Model(
    adaptables = {Resource.class, SlingHttpServletRequest.class},
    defaultInjectionStrategy = DefaultInjectionStrategy.OPTIONAL
)
@Exporter(name = "jackson", extensions = "json")
public class ExampleModel {

    @Self
    private Resource resource;

    @Self
    private SlingHttpServletRequest request;

    @SlingObject
    private ResourceResolver resourceResolver;

    @SlingObject
    private SlingScriptHelper slingScriptHelper;

    @Inject
    @Named("jcr:title")
    private String title;

    @ValueMapValue
    @Default(values = "Default description")
    private String description;

    @OSGiService
    private SomeService someService;

    @Inject
    @Via("childNode")
    private Resource childResource;

    @ScriptVariable
    private org.apache.sling.api.resource.Page currentPage;

    private String initializedValue;

    @PostConstruct
    protected void init() {
        initializedValue = "Initialized for resource: " + resource.getPath();
    }

    @JsonIgnore
    private String internalData = "Should not be serialized";

    @JsonProperty("pageTitle")
    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }

    public String getInitializedValue() {
        return initializedValue;
    }

    public String getInternalData() {
        return internalData;
    }
}</pre>
            </div>              
            <div class="card">
                <h2>Injecting Services into Sling Models</h2>
                <p>Sling Models support injection of OSGi services using annotations like <code>@Inject</code> and <code>@OSGiService</code>. This allows you to access shared business logic and utility classes directly within your model.</p>
                <h3>Using OSGi services with Sling Models</h3>
                <p>You can inject services into a Sling Model using:</p>
                <ul>
                    <li><code>@Inject</code> - Works for most use cases when the service is available in the context.</li>
                    <li><code>@OSGiService</code> - Explicitly used to inject an OSGi service from the OSGi registry. Recommended when dealing with OSGi services.</li>
                </ul>
                <p>Example:</p><pre>
@Inject
@OSGiService
private MyCustomService myService;</pre>
                <h3>Best practices for service injection</h3>
                <ul>
                    <li>Use interfaces for injecting services, not concrete classes.</li>
                    <li>Use <code>@OSGiService</code> for clarity and to avoid context injection issues.</li>
                    <li>Avoid business logic in models; delegate to services where possible.</li>
                    <li>Keep injected services private and avoid exposing them directly through getters.</li>
                    <li>Use <code>@PostConstruct</code> to handle initialization or null-checks if needed.</li>
                </ul>
            </div>
            <div class="card">
                <h2>Model Inheritance and Composition</h2>
                <p>Sling Models in AEM support both inheritance and composition, enabling developers to create reusable and modular components. Inheritance allows one model to extend another, while composition lets you use other models as dependencies within a model.</p>
                <h3>Extending models for reuse</h3>
                <p>Sling Models can extend other models just like regular Java classes. This promotes reuse of common logic or properties across multiple components.</p>
                <ul>
                    <li>Use Java inheritance (<code>extends</code>) to create a base model with shared logic or fields.</li>
                    <li>Override or extend methods in child models as needed.</li>
                    <li>Ensure both base and child classes are annotated with <code>@Model</code> and compatible <code>adaptables</code>.</li>
                </ul>
                <h3>Composing models for modular design</h3>
                <p>Model composition is the practice of including one model inside another using injection. This supports modular design and reduces code duplication.</p>
                <ul>
                    <li>Use <code>@Inject</code> to inject another Sling Model as a dependency.</li>
                    <li>Promotes loose coupling and separation of concerns.</li>
                    <li>Useful for building complex components using simpler, reusable models.</li>
                    <li>Ensure the composed model is adaptable from the correct context (e.g., Resource or Request).</li>
                </ul>
            </div>
            <div class="card">
                <h2>Error Handling in Sling Models</h2>
                <p>Proper error handling in Sling Models ensures stable and maintainable AEM applications. It helps avoid null pointer exceptions, misconfigurations, and unexpected runtime failures, especially when models are consumed in HTL.</p>
                <h3>Common pitfalls and how to avoid them</h3>
                <ul>
                    <li><strong>Missing @Inject/@ValueMapValue:</strong> Always ensure proper annotations are used for injecting properties or services.</li>
                    <li><strong>Incorrect adaptable:</strong> If a model is not adapting correctly, verify the <code>adaptables</code> in the <code>@Model</code> annotation (e.g., <code>Resource.class</code>, <code>SlingHttpServletRequest.class</code>).</li>
                    <li><strong>Optional fields:</strong> Use <code>optional = true</code> to avoid exceptions when properties might be missing.</li>
                    <li><strong>Wrong resource path:</strong> When injecting resources or adapting models, make sure the correct resource path is used.</li>
                </ul>
                <h3>Logging and debugging models</h3>
                <ul>
                    <li>Use SLF4J Logger to add debug and error logs:<pre>private static final Logger LOG = LoggerFactory.getLogger(MyModel.class);</pre></li>
                    <li>Use <code>LOG.debug()</code> or <code>LOG.error()</code> to trace model execution and property values.</li>
                    <li>Use <code>@PostConstruct</code> for sanity checks and initial validations.</li>
                    <li>In HTL, use <code>data-sly-test</code> to verify model availability and display fallback content.</li>
                    <li>Enable DEBUG logging in Felix Console for your package to see detailed logs during development.</li>
                </ul>
            </div>
            <div class="card">
                <h2>Testing Sling Models</h2>
                <p>Testing Sling Models is essential for ensuring the correctness, reliability, and maintainability of AEM components. It involves both unit testing (isolated logic) and integration testing (interaction with AEM framework and JCR).</p>
                <h3>Unit testing Sling Models with Mockito and JUnit</h3>
                <p>Unit tests validate the internal logic of Sling Models by mocking AEM-specific APIs and behaviors using libraries like <code>Mockito</code> and <code>JUnit</code>.</p>
                <ul>
                    <li>Use <code>@Mock</code> to mock dependencies like <code>Resource</code>, <code>SlingHttpServletRequest</code>, and services.</li>
                    <li>Use <code>Mockito.when()</code> to define mock behavior.</li>
                    <li>Inject mocks into the model manually or via reflection.</li>
                    <li>Use assertions to verify expected behavior of getter methods or business logic.</li>
                    <li>Recommended for fast feedback and isolated logic verification.</li>
                </ul>  
                <h3>Integration testing basics</h3>
                <p>Integration tests verify that Sling Models work correctly within the AEM runtime environment, including interactions with JCR content and OSGi services.</p>
                <ul>
                    <li>Use AEM Mocks (e.g., <code>io.wcm.testing.mock.aem.junit5</code>) for a simulated AEM environment.</li>
                    <li>Create mock resources and adapt them to the model using <code>resource.adaptTo(MyModel.class)</code>.</li>
                    <li>Validate property injection, service behavior, and HTL bindings.</li>
                    <li>Best suited for testing complete component functionality.</li>
                </ul>
            </div>
            <div class="card">
                <h2>Best Practices for Sling Models</h2>
                <p>Following best practices while working with Sling Models ensures code clarity, easier maintenance, and better performance in AEM applications.</p>
                <h3>Keeping models clean and maintainable</h3>
                <ul>
                    <li><strong>Follow single responsibility principle:</strong> Each model should focus on a single purpose or component logic.</li>
                    <li><strong>Use meaningful class and method names:</strong> Reflect the role and purpose of the model clearly.</li>
                    <li><strong>Group related models in packages:</strong> Organize models by feature or component to improve project structure.</li>
                    <li><strong>Use interfaces if needed:</strong> Especially when models are shared across bundles or modules.</li>
                    <li><strong>Document models:</strong> Use JavaDocs to explain complex logic or important model behavior.</li>
                </ul>  
                <h3>Performance considerations</h3>
                <ul>
                    <li><strong>Avoid unnecessary service injections:</strong> Inject only what is needed to reduce memory usage and service lookups.</li>
                    <li><strong>Use optional injection where needed:</strong> Prevent unnecessary model failures when certain content is not present.</li>
                    <li><strong>Cache expensive computations:</strong> If your model performs intensive logic, cache results in instance variables after initialization.</li>
                    <li><strong>Use @PostConstruct wisely:</strong> Limit it to only initialization logic and validations.</li>
                    <li><strong>Avoid deep JCR traversal:</strong> Especially in frequently used models, to reduce rendering time and improve page performance.</li>
                </ul>
            </div>   
            <div class="card">
                <h2>Comparison with Other Backend Approaches</h2>
                <p>Sling Models and WCMUsePojo are two popular backend approaches used in AEM to expose data to HTL. Choosing the right one impacts performance, code readability, and ease of development.</p>
                <h3>Sling Models vs WCMUsePojo</h3>
                <ul>
                    <li><strong>Sling Models:</strong> Annotation-based, concise, easy to read, and adaptable from <code>Resource</code> or <code>SlingHttpServletRequest</code>. Supports injection of services, request objects, and value maps using annotations like <code>@Inject</code>, <code>@ValueMapValue</code>, and <code>@OSGiService</code>.</li>
                    <li><strong>WCMUsePojo:</strong> Requires extending the <code>WCMUsePojo</code> class and overriding the <code>activate()</code> method. Less flexible, more verbose, and limited to logic inside the <code>activate()</code> method.</li>
                    <li><strong>Testability:</strong> Sling Models are easier to unit test compared to WCMUsePojo due to less reliance on framework-specific lifecycle methods.</li>
                    <li><strong>Modern Development:</strong> Adobe recommends Sling Models for modern AEM projects due to better integration, clarity, and support.</li>
                </ul>
                <h3>When to use Sling Models over other APIs</h3>
                <ul>
                    <li>When you need clean, annotation-based models that are easy to read and maintain.</li>
                    <li>When working with Sling's adaptable mechanisms like <code>Resource</code> or <code>SlingHttpServletRequest</code>.</li>
                    <li>When you want better support for dependency injection and service integration.</li>
                    <li>When aiming for improved testability and modular design.</li>
                    <li>When building modern AEM components following Adobe's best practices.</li>
                </ul>
              </div>
              <div class="card">
                <h2>Using Sling Models with HTL</h2>
                <p>Sling Models simplify backend logic and make it easy to expose Java data to HTL templates. Binding models in HTL enables clean separation of logic and presentation.</p>
                <h3>Binding Sling Models in HTL with data-sly-use</h3>
                <p>The <code>data-sly-use</code> attribute is used in HTL to instantiate and bind Sling Models to the template, allowing access to model properties and methods.</p>
                <ul>
                    <li>Specify the fully qualified class name of the Sling Model in <code>data-sly-use</code>, for example: <code>data-sly-use.myModel="com.example.models.MyModel"</code>.</li>
                    <li>HTL automatically adapts the current resource or request to the specified model.</li>
                    <li>You can also pass parameters to the model constructor if supported.</li>
                </ul>  
                <h3>Accessing model properties and methods from HTL</h3>
                <p>Once bound, you can access public getters and methods of the Sling Model using expression language:</p>
                <ul>
                    <li><code>${myModel.propertyName}</code> — accesses a getter like <code>getPropertyName()</code>.</li>
                    <li><code>${myModel.methodName()}</code> — calls a public method returning a value.</li>
                    <li>Use expressions to control rendering, like <code>data-sly-test="${myModel.isValid}"</code>.</li>
                    <li>Always design models with clear, safe methods for consumption in HTL.</li>
                </ul>
            </div>                                      
            <script src="https://utteranc.es/client.js" repo="ashishrajbhagat/aem-tutorial" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
        </main>
        <script src="js/script.js"></script>
    </body>
</html>