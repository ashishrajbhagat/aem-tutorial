<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>AEM Tutorial - Runmodes</title>
        <meta name="description" content="Master Adobe Experience Manager (AEM) with our in-depth tutorials, covering AEM components, workflows, servlets, models, Sling, OSGi services, Touch UI dialogs, CRXDE, and more. Perfect for beginners, advanced developers, and AEM architects looking to enhance their skills. Learn how to build scalable and efficient AEM solutions with best practices.">
        <meta name="keywords" content="AEM, Adobe Experience Manager, AEM Tutorial, AEM Training, AEM Components, AEM Workflows, AEM Servlets, AEM Models, AEM Sling, AEM OSGi, AEM Touch UI, AEM CRXDE, AEM DAM, AEM Metadata, AEM Content Fragments, AEM Experience Fragments, AEM Editable Templates, AEM Dispatcher, AEM Forms, AEM Sites, AEM Assets, AEM Cloud, AEM as a Cloud Service, AEM On-Premise, AEM SEO, AEM Best Practices, Learn AEM, AEM Course, AEM Development, AEM Headless, AEM SPA, AEM React, AEM Angular, AEM HTL, AEM Sightly, AEM Frontend, AEM Backend, AEM Workflow Development, AEM Performance Optimization, AEM Interview Questions">
        <meta name="author" content="Ashish Raj">
        <link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png">
        <link rel="manifest" href="/site.webmanifest">
        <link rel="stylesheet" href="css/styles.css">
    </head>
    <body>
        <div class="sidebar" id="sidebar">
            <div class="logo">
                <h2>AEM Tutorial</h2>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebarSearch" placeholder="🔍 Search..." />
            </div>
            <nav class="nav" id="sidebar-nav"></nav>
            <div class="footer">
                <p>&copy; 2025 AEM Tutorial</p>
            </div>
        </div>
        <span class="hamburger" onclick="toggleMenu()">&#9776;</span>
        <main class="content" id="content">
            <h1>Runmodes</h1>
            <section class="card">
                <h2>What are Runmodes in AEM?</h2>
                <p>Runmodes in Adobe Experience Manager (AEM) are a powerful mechanism that allow you to define different behaviors or configurations for the same AEM codebase based on the environment where it is running. This enables developers and DevOps teams to configure the AEM instance differently for local development, staging, production, testing, etc.</p>
                <p>These modes control which configurations, bundles, scripts, content packages, and services are enabled at runtime—thereby promoting clean separation of concerns and environment-specific behavior.</p>
                <p><strong>Why Use Runmodes?</strong></p>
                <ul>
                    <li>To isolate configurations per environment</li>
                    <li>To enable or disable features like analytics, error reporting, debugging</li>
                    <li>To deploy tools or bundles only in dev or staging but not in prod</li>
                    <li>To reduce risk by separating production logic from dev/test logic</li>
                </ul>
            </section>
            <section class="card">
                <h2>Commonly Used Runmodes</h2>
                <p>AEM supports one or more runmodes at the same time. These runmodes are combined to describe the role and environment of an instance. The two major categories of runmodes are:</p>
                <h3>Instance Role Runmodes:</h3>
                <ul>
                    <li><strong>author:</strong> For content creation, review, workflow handling, and management.</li>
                    <li><strong>publish:</strong> For delivering final published content to end users (typically behind a dispatcher/CDN).</li>
                </ul>
                <h3>Environment Runmodes:</h3>
                <ul>
                    <li><strong>dev:</strong> Local or developer-specific environments.</li>
                    <li><strong>qa/test:</strong> For quality assurance, testing teams.</li>
                    <li><strong>stage/staging:</strong> Mirror of production for validation before release.</li>
                    <li><strong>prod:</strong> Live, production environment for end users.</li>
                </ul>
                <p><strong>Examples:</strong></p>
                <ul>
                    <li><code>author + dev</code>: Developer's local instance</li>
                    <li><code>publish + prod</code>: Production-facing publish server</li>
                    <li><code>author + qa</code>: QA testing for content editing</li>
                </ul>
            </section>
            <section class="card">
                <h2>How to Configure Runmodes in AEM</h2>
                <p>Runmodes can be configured in three primary ways depending on your deployment method.</p>
                <h3>1. sling.properties File</h3>
                <p>You can edit the <code>sling.properties</code> file located at <code>crx-quickstart/conf/sling.properties</code>:</p>
                <pre>sling.run.modes=author,dev</pre>
                <h3>2. JVM Parameters (during jar startup)</h3>
                <p>When launching AEM via the JAR, specify runmodes using the <code>-r</code> flag:</p>
                <pre>java -jar aem-quickstart.jar -r author,dev</pre>
                <h3>3. Environment Variable (for Docker/Kubernetes)</h3>
                <pre>export SLING_OPTS="-Dsling.run.modes=author,prod"</pre>
                <p>This is commonly used in cloud-native and containerized setups.</p>
            </section>
            <section class="card">
                <h2>Using Runmodes for OSGi Configuration</h2>
                <p>OSGi configurations can be scoped to runmodes using special folders under <code>/apps/&lt;project&gt;</code>. These folders ensure only the configurations relevant to the current environment are loaded.</p>
                <p><strong>Folder Structure Example:</strong></p>
                <pre>/apps/myproject/config.author/com.mycompany.MyService.cfg.json</pre>
                <p>This configuration is only loaded if <code>author</code> runmode is active.</p>
            </section>
            <section class="card">
                <h2>Environment-Specific OSGi Configuration Folders</h2>
                <p>Runmodes affect which configuration folder AEM reads from. These folders are typically:</p>
                <ul>
                    <li><code>config</code> - Default fallback configuration</li>
                    <li><code>config.dev</code>, <code>config.stage</code>, <code>config.prod</code> - Single runmode folders</li>
                    <li><code>config.author.dev</code> - Combined runmodes (most specific)</li>
                </ul>
                <p><strong>Folder Resolution Order:</strong></p>
                <pre>config.author.dev → config.author → config</pre>
                <p>The most specific folder matching all active runmodes wins.</p>
            </section>
            <section class="card">
                <h2>Multi-Level Runmode Folders</h2>
                <p>If an instance runs with multiple runmodes like <code>author</code> and <code>dev</code>, you can create a folder like:</p>
                <pre>/apps/myproject/config.author.dev/</pre>
                <p>This allows defining fine-grained OSGi settings for very specific combinations.</p>
            </section>
            <section class="card">
                <h2>Runmode Resolution Priority</h2>
                <p>When multiple folders match the current runmodes, AEM uses the most specific one.</p>
                <ul>
                    <li><code>config</code> → loaded if no runmode-specific config exists</li>
                    <li><code>config.author</code> → overrides <code>config</code></li>
                    <li><code>config.author.dev</code> → overrides both if both runmodes are active</li>
                </ul>
                <p><strong>Important:</strong> Avoid duplicating the same PID in multiple folders unless you intend to override.</p>
            </section>
            <section class="card">
                <h2>.cfg.json vs .config</h2>
                <p>OSGi configuration files in AEM can be written in two formats, and both serve the same purpose — to define configuration values for a specific OSGi service.</p>
                <h3>1. <code>.cfg.json</code> (Recommended for AEMaaCS)</h3>
                <p>This is a structured JSON format. It's easier to read, modern, and preferred for Adobe Experience Manager as a Cloud Service.</p>
                <p><strong>Example (.cfg.json):</strong></p>
                <pre>{
  "enabled": true,
  "retryCount": 3,
  "emailRecipients": ["dev@example.com", "admin@example.com"],
  "serviceName": "UserSyncService"
}</pre>
                <h3>2. <code>.config</code> (Java Properties Style)</h3>
                <p>This is the traditional key-value format (property = value). It is still supported and useful, especially in older or on-prem setups.</p>
                <p><strong>Example (.config):</strong></p>
                <pre>
enabled=Btrue
retryCount=3
emailRecipients=["dev@example.com","admin@example.com"]
serviceName="UserSyncService"
</pre>
                <p><strong>Note:</strong> In <code>.config</code> files:</p>
                <ul>
                    <li>Boolean values must be capitalized as <code>Btrue</code> or <code>Bfalse</code></li>
                    <li>String arrays should be enclosed in brackets <code>[]</code> with quotes</li>
                    <li>Always wrap string values in double quotes if they contain special characters or spaces</li>
                </ul>
            </section>
            <section class="card">
                <h2>Factory Configurations</h2>
                <p>Factory configurations let you create multiple instances of the same service with different values. Naming convention uses a tilde (<code>~</code>).</p>
                <pre>
com.mycompany.Service~instance1.cfg.json
com.mycompany.Service~instance2.cfg.json</pre>
                <p>AEM treats these as separate service configurations.</p>
            </section>
            <section class="card">
                <h2>Installing Content Packages Based on Runmodes</h2>
                <p>AEM uses <code>install</code> folders under apps to conditionally install packages:</p>
                <ul>
                    <li><code>/apps/myproject/install</code> - All runmodes</li>
                    <li><code>/apps/myproject/install.dev</code> - Only if <code>dev</code> is active</li>
                    <li><code>/apps/myproject/install.author</code> - Only on author instance</li>
                </ul>
                <p>Use case: Install Groovy Console only in dev, disable integrations in staging, etc.</p>
            </section>
            <section class="card">
                <h2>How to Check Active Runmodes</h2>
                <ul>
                    <li>
                        <strong>Via Web Console:</strong>
                        Go to <code>/system/console/status-slingsettings</code> and check the "Run Modes" section.
                    </li>
                    <li>
                        <strong>Via Logs:</strong>
                        Inspect <code>error.log</code> on startup for a line like:
                        <pre>Detected run modes: [author, dev]</pre>
                    </li>
                </ul>
            </section>
            <section class="card">
                <h2>Best Practices</h2>
                <ul>
                    <li>Always use meaningful runmodes (e.g., <code>dev</code>, <code>qa</code>, <code>prod</code>).</li>
                    <li>Separate author and publish configs cleanly using folders.</li>
                    <li>Use <code>.cfg.json</code> for future-proof compatibility.</li>
                    <li>Keep sensitive values (e.g., passwords, URLs) out of shared config folders.</li>
                    <li>Avoid logic branching in code—let configurations control behavior.</li>
                </ul>
            </section>
            <section class="card">
                <h2>Conclusion</h2>
                <p>Runmodes provide the backbone of flexible, scalable AEM deployments. Whether you are working on an enterprise cloud-native setup or a simple on-premise installation, mastering runmodes will give you strong control over behavior and environment separation.</p>
                <p>By using structured folders like <code>config.&lt;runmode&gt;</code> and <code>install.&lt;runmode&gt;</code>, and understanding resolution priorities, you can avoid conflicts and ensure consistency across environments.</p>
            </section>
            <script src="https://utteranc.es/client.js" repo="ashishrajbhagat/aem-tutorial" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
        </main>
        <script src="js/script.js"></script>
    </body>
</html>