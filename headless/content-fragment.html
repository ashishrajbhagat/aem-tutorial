<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>AEM Tutorial - Content Fragment</title>
		<meta name="description" content="Master Adobe Experience Manager (AEM) with our in-depth tutorials, covering AEM components, workflows, servlets, models, Sling, OSGi services, Touch UI dialogs, CRXDE, and more. Perfect for beginners, advanced developers, and AEM architects looking to enhance their skills. Learn how to build scalable and efficient AEM solutions with best practices.">
		<meta name="keywords" content="AEM, Adobe Experience Manager, AEM Tutorial, AEM Training, AEM Components, AEM Workflows, AEM Servlets, AEM Models, AEM Sling, AEM OSGi, AEM Touch UI, AEM CRXDE, AEM DAM, AEM Metadata, AEM Content Fragments, AEM Experience Fragments, AEM Editable Templates, AEM Dispatcher, AEM Forms, AEM Sites, AEM Assets, AEM Cloud, AEM as a Cloud Service, AEM On-Premise, AEM SEO, AEM Best Practices, Learn AEM, AEM Course, AEM Development, AEM Headless, AEM SPA, AEM React, AEM Angular, AEM HTL, AEM Sightly, AEM Frontend, AEM Backend, AEM Workflow Development, AEM Performance Optimization, AEM Interview Questions">
		<meta name="author" content="Ashish Raj">
		<link rel="apple-touch-icon" sizes="180x180" href="../images/favicon/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon/favicon-16x16.png">
		<link rel="manifest" href="/site.webmanifest">
		<link rel="stylesheet" href="../css/styles.css">
	</head>
	<body>
		<div class="sidebar" id="sidebar">
			<div class="logo">
				<h2><a href="/">AEM Tutorial</a></h2>
			</div>
            <div class="sidebar-search">
                <input type="text" id="sidebarSearch" placeholder="ðŸ” Search..." />
            </div>
			<nav class="nav" id="sidebar-nav"></nav>
			<div class="footer">
				<p>&copy; 2025 AEM Tutorial</p>
			</div>
		</div>
		<span class="hamburger" onclick="toggleMenu()">&#9776;</span>
		<main class="content" id="content">
			<h1>Content Fragment</h1>
			<section class="card">
				<h2>Introduction to Content Fragments</h2>
				<p>Content Fragments (CFs) in Adobe Experience Manager (AEM) are reusable, channel-neutral content assets that allow authors to manage and deliver structured content independent of layout. They are content-centric components that enable authors to manage content as modular, reusable blocks. Each fragment is based on a model that defines its structure, and it can include text, dates, numbers, boolean values, and even nested content. CFs are ideal for use in headless CMS scenarios and support both structured fields and rich text editing. Content Fragments are not tied to any specific presentation or design, making them perfect for omnichannel content delivery. They allow for the creation of content once and reuse it across various channels like websites, mobile apps, and third-party platforms.</p>
				<h3>Use-cases for Structured and Channel-Neutral Content</h3>
				<ul>
					<li>Publishing consistent content across web, mobile, and IoT platforms.</li>
					<li>Separating content from layout for headless content delivery using GraphQL or REST APIs.</li>
					<li>Creating structured product descriptions, FAQs, or author bios.</li>
					<li>Supporting multilingual and localized content delivery.</li>
				</ul>
				<h3>Key Differences Between Content Fragments and Experience Fragments</h3>
				<ul>
					<li><strong>Content Fragments:</strong> Channel-neutral, layout-free content used mainly in headless or structured content delivery.</li>
					<li><strong>Experience Fragments:</strong> Include layout, components, and design; used for reusable content blocks that maintain visual consistency across pages or channels.</li>
					<li>CFs are data-focused; XFs are presentation-focused.</li>
					<li>CFs are delivered as JSON; XFs can be delivered as HTML and used in pages or exported to channels like Adobe Target.</li>
				</ul>
			</section>
			<section class="card">
				<h2>Content Fragment Models</h2>
				<p>Content Fragment Models in AEM define the structure and schema of a Content Fragment. They act as blueprints, allowing authors to create structured, reusable content entries using predefined fields and data types. Models ensure consistency and enforce validation across fragments, making them essential for headless CMS implementations.</p>
				<h3>What is a Content Fragment Model?</h3>
				<p>A Content Fragment Model is a configurable data structure that defines the fields and types of content to be used within a Content Fragment. It is created within the AEM Content Fragment Model editor and stored under the appropriate Configuration Browser path (e.g., /conf).</p>
				<h3>Creating and Configuring CF Models</h3>
				<p>To create a CF Model, navigate to Tools &gt; Assets &gt; Content Fragment Models in AEM. Choose the appropriate configuration folder (e.g., /conf/my-site), then create a new model by defining its title and adding fields like text, date, number, boolean, JSON objects, or even fragment references. You can set each field as required, optional, or with default values.</p>
				<h3>Data Types Supported in CF Models</h3>
				<ul>
					<li>Single line text</li>
					<li>Multi line text (plain or rich text)</li>
					<li>Number</li>
					<li>Date and time</li>
					<li>Boolean</li>
					<li>Enumeration (dropdowns or radio groups)</li>
					<li>Fragment reference</li>
					<li>JSON object</li>
					<li>Content reference (e.g., image, asset)</li>
				</ul>
				<h3>Managing Field Validation and Constraints</h3>
				<p>AEM allows you to configure validations such as mandatory fields, regex patterns, min/max character lengths, and numeric ranges. These validations help enforce content integrity and reduce manual errors during authoring.</p>
				<h3>Versioning and Localization Support</h3>
				<p>Content Fragments created from models support version control, allowing authors to track changes and restore previous versions. Additionally, AEM enables localization and translation of fragments into multiple languages, facilitating global content delivery with consistency.</p>
			</section>
			<section class="card">
				<h2>Creating and Managing Content Fragments</h2>
				<p>Content Fragments (CFs) in AEM allow authors to manage both structured and unstructured content independently of layout. They are created based on models and can include variations to support multi-channel content reuse. CFs can be tagged and organized efficiently for better content governance and discovery.</p>
				<h3>Steps to Create a Content Fragment Using a Model</h3>
				<p>To create a Content Fragment:</p>
				<ul>
					<li>Go to <strong>Assets &gt; Files</strong> and select a folder to store the fragment.</li>
					<li>Click <strong>Create &gt; Content Fragment</strong>.</li>
					<li>Select a <strong>Content Fragment Model</strong> (defined under /conf).</li>
					<li>Provide a title and name, then click <strong>Create</strong>.</li>
					<li>Open the fragment in the editor to start authoring content.</li>
				</ul>
				<h3>Authoring Content in Structured vs. Freeform Mode</h3>
				<p>CFs support two modes of content authoring:</p>
				<ul>
					<li><strong>Structured Mode</strong> - Based on the fields defined in the model; ensures content consistency and validation.</li>
					<li><strong>Freeform Mode</strong> - Uses Rich Text Editor without strict schema; offers flexibility but less control.</li>
				</ul>
				<h3>Working with Variations in CFs</h3>
				<p>Variations allow you to create alternate versions of the same content for different channels or contexts. Each variation can override or supplement the Master content, enabling tailored experiences for mobile, social, or regional use cases.</p>
				<h3>Tagging and Organizing Content Fragments</h3>
				<p>CFs can be tagged using AEM's taxonomy to categorize content and improve searchability. Organizing them in folders, using metadata, and applying consistent naming conventions helps in managing content at scale.</p>
			</section>
			<section class="card">
				<h2>Using Content Fragments on Pages</h2>
				<p>Content Fragments (CFs) can be easily used on AEM Sites pages by leveraging the built-in <strong>Content Fragment Component</strong>. This allows authors to display structured or rich text content authored in fragments directly on web pages. Developers can also customize the presentation using Sling Models and additional formatting logic.</p>
				<h3>Inserting CFs using the Content Fragment Component</h3>
				<p>To insert a CF on a page, drag and drop the <strong>Content Fragment</strong> core component (v1 or v2) onto the page. Then, configure the component by selecting the appropriate fragment path from the content repository.</p>
				<h3>Displaying Specific Elements and Variations</h3>
				<p>The Content Fragment component allows you to choose:</p>
				<ul>
					<li><strong>Specific Elements</strong> - Select which fields (e.g., Title, Body, Image) to render.</li>
					<li><strong>Variations</strong> - Display alternate versions of the fragment based on your use case (e.g., Mobile Variation, Social Variation).</li>
				</ul>
				<h3>Styling and Formatting Content Fragments</h3>
				<p>Content Fragments can be styled by wrapping the component with custom HTML/CSS classes or extending the core component to apply custom markup. Authors can also use rich text formatting within fragments for inline styles.</p>
				<h3>Using Sling Models to Access CF Content</h3>
				<p>Developers can create Sling Models to adapt a fragment resource and access its elements programmatically. This approach gives you fine-grained control to query fragment data and display it dynamically in HTL:</p>
				<pre>
@Model(adaptables = Resource.class)
public class CustomFragmentModel {
    @Inject
    private ContentFragment contentFragment;

    public String getElementValue(String elementName) {
        return contentFragment.getElement(elementName).getContent();
    }
}</pre>
				<p>This model can be used in your HTL using <code>data-sly-use</code> to render custom fields from a fragment.</p>
			</section>
			<section class="card">
				<h2>Headless Content Delivery</h2>
				<p>Adobe Experience Manager (AEM) supports headless content delivery, enabling content reuse across multiple channels like web, mobile, IoT, and more. Content Fragments (CFs) play a central role in this architecture by providing structured content that can be delivered via JSON. AEM provides two major ways to expose CFs: using <strong>.model.json</strong> through Content Services and <strong>GraphQL APIs</strong>.</p>
				<h3>Delivering CFs using AEM Content Services</h3>
				<p>When Content Fragments are placed on a Sites page using the <strong>Content Fragment Component</strong>, AEM automatically generates a JSON version of the page content via the <strong>.model.json</strong> URL. This allows frontend frameworks like React or Angular to consume the content directly.</p>
				<p><strong>Example:</strong><br>
					Accessing CF JSON via <code>/content/we-retail/language-masters/en/model-page.model.json</code>
				</p>
				<h3>Accessing CF JSON via .model.json</h3>
				<p>If you want to fetch the JSON for a standalone Content Fragment without using a page, you can do so by accessing its <code>.model.json</code> endpoint directly (only available in AEM as a Cloud Service and AEM 6.5+):</p>
				<p><strong>Example:</strong><br>
					<code>/content/dam/myproject/fragments/my-article.model.json</code>
				</p>
				<h3>Using GraphQL APIs to Query CFs</h3>
				<p>AEM provides a built-in <strong>GraphQL API</strong> for querying Content Fragments created using structured models. This allows frontend developers to retrieve only the data they need and supports complex use cases like filtering, pagination, and querying nested fragment references.</p>
				<pre>
query {
  myArticleList {
    items {
      title
      author
      body {
        html
      }
    }
  }
}</pre>
				<h3>Filtering, Pagination, and Nested Structures in GraphQL</h3>
				<p>The GraphQL endpoint supports:</p>
				<ul>
					<li><strong>Filtering</strong> - Use GraphQL filters to fetch specific fragments based on property values (e.g., title, tags).</li>
					<li><strong>Pagination</strong> - Use <code>limit</code> and <code>offset</code> to control result size and implement infinite scroll or page-wise navigation.</li>
					<li><strong>Nested Structures</strong> - Fetch deeply nested content by resolving fragment references and multi-field arrays.</li>
				</ul>
				<p><strong>Example with filter and pagination:</strong></p>
				<pre>
query {
  myArticleList(filter: { author: { _expressions: [{ value: "Ashish", _operator: EQUALS }] } }, limit: 5, offset: 0) {
    items {
      title
      author
    }
  }
}</pre>
			</section>
			<section class="card">
				<h2>GraphQL and Content Fragments</h2>
				<p>Adobe Experience Manager (AEM) provides powerful support for GraphQL to query structured Content Fragments. This enables efficient headless content delivery where frontend applications can fetch only the necessary data via a flexible and scalable API layer.</p>
				<h3>Setting up GraphQL Endpoints</h3>
				<p>To use GraphQL in AEM, you need to publish your Content Fragment Models. AEM automatically generates a GraphQL schema from these models. The endpoint is available at:</p>
				<p><code>/content/graphql/global/endpoint-name.graphql</code></p>
				<p>You can configure endpoints in AEM through the GraphQL console or CRX/DE.</p>
				<h3>Writing Queries for CFs</h3>
				<p>Once the endpoint is ready, you can write GraphQL queries to retrieve structured content. Queries are based on the fields defined in the Content Fragment Models.</p>
				<pre>
query {
  articleModelList {
    items {
      title
      publishDate
      body {
        html
      }
    }
  }
}</pre>
				<h3>Using Persisted Queries</h3>
				<p>Persisted queries allow you to save predefined GraphQL queries on the server. Frontend applications can then access these queries via a unique name or ID, improving security and performance by avoiding large query strings in the URL.</p>
				<p><strong>Steps:</strong></p>
				<ol>
					<li>Save the query using the AEM GraphQL console or API.</li>
					<li>Access it via <code>/graphql/execute.json/endpoint-name/query-name</code></li>
				</ol>
				<p>This approach prevents injection attacks and reduces payload size.</p>
				<h3>Caching and Optimization for Headless Delivery</h3>
				<p>For performance and scalability, AEM supports Dispatcher caching of GraphQL persisted query results. To optimize delivery:</p>
				<ul>
					<li>Use persisted queries to leverage caching effectively.</li>
					<li>Enable caching rules for <code>/graphql/execute.json</code> in Dispatcher.</li>
					<li>Design GraphQL queries to fetch only needed fields.</li>
					<li>Paginate results where necessary.</li>
				</ul>
				<p>Proper use of caching helps ensure faster response times and reduced load on AEM publish instances.</p>
			</section>
			<section class="card">
				<h2>Content Fragment Console and Tools</h2>
				<p>The Content Fragment (CF) console in Adobe Experience Manager provides authors with a centralized interface to manage, search, and update content fragments efficiently. It offers tools for filtering, bulk operations, and metadata management, making it easy to handle large-scale content authoring workflows.</p>
				<h3>Navigating the CF Console</h3>
				<p>You can access the Content Fragment console by navigating to <code>Assets &gt; Files</code> and then browsing to the folder containing your content fragments. AEM displays a card or list view of available fragments, where you can view status, model type, and last modification details.</p>
				<h3>Searching and Filtering CFs</h3>
				<p>The console includes a powerful search and filter bar that allows authors to quickly locate fragments by title, tags, content model, or metadata fields. This is especially useful when dealing with hundreds of content fragments across multiple folders and projects.</p>
				<h3>Bulk Operations and Metadata Updates</h3>
				<p>AEM enables bulk actions on multiple content fragments, including:</p>
				<ul>
					<li><strong>Move</strong> - Reorganize fragments across folders.</li>
					<li><strong>Delete</strong> - Remove multiple fragments at once.</li>
					<li><strong>Update Metadata</strong> - Edit common metadata fields like title, tags, and status across selected fragments.</li>
					<li><strong>Publish/Unpublish</strong> - Activate or deactivate content for headless or page-based delivery.</li>
				</ul>
				<p>These tools help streamline content governance and batch operations for large teams working in headless or hybrid CMS environments.</p>
			</section>
			<section class="card">
				<h2>Programmatic Access to Content Fragments</h2>
				<p>Adobe Experience Manager provides various APIs and tools for developers to access, read, and create Content Fragments programmatically. This is useful for automating content ingestion, building integrations, or implementing custom logic that manipulates structured content.</p>
				<h3>Reading CFs using Sling Models</h3>
				<p>You can adapt a <code>Resource</code> to a Sling Model that uses <code>ContentFragment</code> API. This allows you to access fields and elements of the CF in a strongly typed way:</p>
				<pre>
@Model(adaptables = Resource.class)
public class ArticleModel {

    @Self
    private Resource resource;

    private ContentFragment contentFragment;

    @PostConstruct
    protected void init() {
        contentFragment = resource.adaptTo(ContentFragment.class);
    }

    public String getTitle() {
        return contentFragment != null ? contentFragment.getElement("title").getContent() : "";
    }
}</pre>
				<h3>Accessing CF data using Java API or QueryBuilder</h3>
				<p>Content Fragments are stored under <code>/content/dam</code> and can be queried using the JCR API or QueryBuilder. You can filter by <code>dam:Asset</code> type and check for fragment metadata.</p>
				<pre>
// Example using QueryBuilder
Map&lt;String, String%gt; params = new HashMap&lt;&gt;();
params.put("type", "dam:Asset");
params.put("path", "/content/dam/my-site/fragments");
params.put("1_property", "jcr:content/contentFragment");
params.put("1_property.value", "true");

SearchResult result = queryBuilder.createQuery(PredicateGroup.create(params), session).getResult();</pre>
				<h3>Creating CFs Programmatically (Groovy, Java)</h3>
				<p>You can create Content Fragments programmatically using Java or Groovy scripts by creating the appropriate node structure and properties:</p>
				<pre>
// Using Java to create a CF structure
Node cfNode = parentNode.addNode("my-fragment", "dam:Asset");
Node metadata = cfNode.addNode("jcr:content", "nt:unstructured");
metadata.setProperty("contentFragment", true);
metadata.setProperty("cq:model", "/conf/my-site/settings/dam/cfm/models/article");</pre>
				<p>For scripting, the <strong>ACS AEM Tools Groovy Console</strong> can be used to run Groovy scripts that create or update fragments dynamically based on business logic or data imports.</p>
			</section>
			<section class="card">
				<h2>Best Practices for Content Fragments</h2>
				<p>To ensure Content Fragments (CFs) are scalable, reusable, and easy to manage, it's important to follow established best practices when modeling, structuring, and naming them. These practices enhance authoring experience, content governance, and omnichannel content delivery.</p>
				<h3>Structuring CF Models for Reusability</h3>
				<p>Design Content Fragment Models to be generic and reusable across different fragments and use cases. Use shared field definitions and reference models when applicable. This ensures that similar types of content can be authored consistently across projects.</p>
				<h3>Keeping CFs Clean and Minimal</h3>
				<p>Avoid cluttering fragments with too many fields. Only include fields that are meaningful and essential for the intended use cases. Simplicity helps authors focus on relevant content and reduces the risk of errors.</p>
				<h3>Naming Conventions and Categorization</h3>
				<p>Use consistent and meaningful names for both CFs and their fields. Organize models and fragments in folders based on content type or business domain. Apply tags and metadata to support searchability and governance.</p>
				<h3>Avoiding Excessive Nesting or Over-Modeling</h3>
				<p>While nested models or multifield structures can be powerful, overusing them can make authoring complex and performance heavy. Aim for a balance between flexibility and simplicity. Flatten data structures where possible.</p>
			</section>
			<section class="card">
				<h2>Integration Use Cases</h2>
				<p>Content Fragments (CFs) offer powerful integration capabilities, allowing structured content to be reused across frameworks, personalization tools, and marketing platforms. These use cases enable consistent and scalable content delivery across digital channels.</p>
				<h3>Using CFs in React/Angular SPAs</h3>
				<p>Content Fragments can be exposed via AEM's GraphQL or JSON APIs and consumed by Single Page Applications (SPAs) built with React or Angular. This enables content authors to manage content in AEM while front-end teams can dynamically render content in modern JS frameworks.</p>
				<h3>Integration with Adobe Target or Launch</h3>
				<p>CFs can be used alongside Adobe Target for personalized content delivery. Using structured content in fragments enables dynamic targeting, testing, and segmentation. Adobe Launch can be used to manage tags and scripts that support CF-based personalization workflows.</p>
				<h3>Personalization and Translation Workflows</h3>
				<p>CFs support headless personalization strategies through metadata tagging and structured models. They can be integrated with AEM Translation workflows for managing multilingual content. This ensures content can be personalized and localized effectively across regions and audiences.</p>
			</section>
			<section class="card">
				<h2>Common Issues and Troubleshooting</h2>
				<p>While working with Content Fragments (CFs) in AEM, developers and authors may encounter common issues. Identifying and resolving these early ensures smooth content delivery and accurate rendering across channels.</p>
				<h3>CFs Not Showing on Page</h3>
				<p>This may happen if the fragment is not published, not correctly referenced in the component, or if the model used by the fragment is missing. Verify the CF is published and that your component is correctly reading it using Sling Models or API calls.</p>
				<h3>GraphQL Query Not Returning Data</h3>
				<p>Ensure that the CF model and content fragments are published, and the GraphQL endpoint is enabled. Also, confirm that the query syntax matches the structure defined in the Content Fragment Model.</p>
				<h3>CF Model Not Found/Published</h3>
				<p>If a model is missing or unpublished, CFs based on that model will not work correctly. Go to AEM's CF Models section, verify the model exists, and publish it to make it available to content fragments and API queries.</p>
				<h3>Localization Not Reflected</h3>
				<p>Ensure language copies of CFs exist and are properly linked using AEM's Language Root structure. Check if the correct language version of the CF is being referenced in the component or GraphQL request.</p>
			</section>
			<script src="https://utteranc.es/client.js" repo="ashishrajbhagat/aem-tutorial" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
		</main>
		<script src="../js/script.js"></script>
	</body>
</html>
